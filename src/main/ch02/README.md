# 2. 리팩터링 원칙

## 2.1 리팩터링

----
소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이행하고 수정하기 쉽도록 내부 구조를 변경하는 기법

 
1. 리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다.

2. 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.

## 2.2 두 개의 모자

----
> '기능 추가' 모자 & '리팩터링' 모자
 
1. 기능을 추가할 때는 기존 코드를 건드리지 않고 새 기능을 추가
2. 리팩터링을 할 때는 기능 추가를 하지 않고 코드 재구성

전체 작업 시간이 10분 정도로 짧다 해도, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 작업 방식의 차이를 분명하게 인식

## 2.3 리팩터링하는 이유

----
리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 아니지만 코드를 건강한 상태로 유지하는 데 도와주는 약이다.

1. 소프트웨어 설계가 좋아진다

아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 부폐가 가속화된다. 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다.

코드가 길면 실수 없이 수정하기 어려워지고 이해해야 할 코드량도 늘어난다. 비슷한 일을 하는 코드가 산재해 있다면 코드를 수정했을 때 예상대로 작동하지 않을 수 있다. 리팩터링을 통해 반복되는 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있다.

2. 소프트웨어를 이해하기 쉬워진다

프로그램을 동작시키는 데만 신경 쓰는 것은 나중에 그 코드를 다룰 개발자에 대한 배려가 없는 것이다. 리팩터링은 코드가 더 잘 읽히게 도와준다.


3. 리팩터링하면 버그를 쉽게 찾을 수 있다

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 리팩터링하면 코드가 하는 일을 깊이 파악할 수 있어서 깨달은 것을 코드에 금방 반영할 수 있다.


4. 리팩터링하면 프로그래밍 속도를 높일 수 있다

얼핏 반대가 아닌가라고 생각할 수 있지만, 리팩터링하면 코드 개발 속도를 높일 수 있다.

내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 고치는 방법을 쉽게 찾을 수 있다. 모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다. 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 쉬워집니다. 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.

> 마틴 파울러는 이 효과를 설계 지구력 가설 (Design Stamina Hypothesis) 라고 부른다. 이는 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.

## 2.4 언제 리팩터링해야 할까?

----

### 3의 법칙
```
1. 그냥 한다.
2. 비슷한 일을 두 번해도 일단 계속 한다.
3. 비슷한 일을 세 번하면 리팩터링한다.
```

1. 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
- 리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전.
- 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬어질 만한 부분을 찾는다.
- 준비를 위한 리팩터링(Preparatory Refactoring)으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이며, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수 있음

2. 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
- 코드를 분석할 때 리팩터링을 해보면, 하지 않았을 때 도달하지 못했을 더 깊은 수준까지 이해하게 됨
- 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있음

3. 쓰레기 줍기 리팩터링
- 코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있음
- 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 하던 일을 끝내고 처리

4. 계획된 리팩터링과 수시로 하는 리팩터링
- 수시로 하는 리팩터링은 프로그래밍 과정에 리팩터링을 자연스럽게 녹인 것 -> 리팩터링 일정을 따로 잡지 않고 기능을 추가하거나 버그를 잡는 동안 함께 진행
- 계획된 리팩터링은 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선하는 것 -> 무조건 나쁜 것은 아님
- 리팩터링 작업은 대부분 드러나지 않게, 기회가 될 때마다 해야 함

5. 오래 걸리는 리팩터링
- 리팩터링은 대부분 몇 분 안에 끝남, 길어야 몇 시간 정도
- 하지만, 팀 전체가 참여해서 많은 시간을 할애하는 대규모 리팩터링도 있음
  - 이 때는 문제를 몇 주에 걸쳐 조금씩 해결해나가는 편이 효과적일 때가 많음
  - 누구든지 리팩터링해야할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선
  - 일부를 변경해도 모든 기능이 항상 올바르게 동작: 예컨데 추상화로 갈아타기(Branch by Abstration)가 있음

6. 코드 리뷰에 리팩터링 활용하기
- 리팩터링은 다른 이의 코드를 리뷰하는 데도 도움이 됨

7. 관리자에게는 뭐라고 말해야 할까?
- 어설픈 재구성 작업은 하지 말라
- 기술을 모르는 관리자와 고객은 있을 수 있음: 이들은 코드베이스의 건강 상태가 생산성에 미치는 영햐을 모름
  - 이들에게는 "리팩터링한다고 말하지 말라"
  - 무시하라는 말이 아니라, 개발자는 기능을 구현하는 것이 업무이고 업무를 효율적으로 하는 방법은 리팩터링임

8. 리팩터링하지 말아야 할 때
- 굳이 수정할 필요가 없다면 리팩터링 하지 않음
  - 외부 API 다루듯 호출해서 쓰는 코드라면 내부 동작을 이해해야 할 시점에 리팩터링을 하는 것이 효과적임 
- 처음부터 새로 작성하는 게 쉽다면 리팩터링 하지 않음 

## 2.5 리팩터링 시 고려할 문제

----

1. 새 기능 개발 속도 저하

리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

- 새 기능을 구현해넣기 편해지겠다 싶은 리팩터링이라면 주저하지 않고 먼저함
- 개발팀을 이끌고 있다면 코드베이스가 더 건강해지는 것을 추구한다는 사실을 팀원들에게 명확히 밝혀야 함
- 리팩터링은 '클린코드'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 하는 것이 아님
  - 리팩터링은 경제적인 이유로 하는 것 -> 개발 기간을 단축시키고, 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여줌

2. 코드 소유권

리팩터링하다 보면 모듈의 내부분 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많음

- 함수를 호출하는 코드의 소유자가 다른 팀이라서 나에게는 쓰기 권한이 없을 수 있음
- 또는, 바꾸려는 함수가 고객에게 API로 제공된 것이라면 누가 얼마나 쓰고 있는지, 실제로 쓰이는지도 모를 수 있음
- 이 또한 리팩터링이 가능함, 제약이 따를 뿐임
- 저자는 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대하는 입장
  - 저자가 선호하는 방식은 코드의 소유권을 팀에 두는 것
  - 코드 소유권을 느슨하게 정하는 방식은 여러 팀으로 구성된 조직에도 적용 가능
  - 어떤 팀은 오픈소스 개발 모델을 권장하기도 함

3. 브랜치
4. 테스팅
5. 레거시 코드
6. 데이터베이스

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

----
리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해주는데 있음

- 현재까지 파악한 요구사항만 해결하는 소프트웨어를 구축, 진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 그에 맞게 아키텍처도 리팩터링
  - 이러한 설계 방식을 간결한 설계(simple desing), 점진적 설계(incremental design), YAGNI(you aren't going to need it: 필요 없을거다) 등으로 불림

## 2.7 리팩터링과 소프트웨어 개발 프로세스

----

## 2.8 리팩터링과 성능

----

리팩터링을 하면 소프트웨어가 느려질 수 있는 건 사실, 하지만 그와 동시에 성능을 튜닝하기 더 쉬워짐
```
먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것
```

리팩터링을 잘 해두면 최적화에 두 가지 면에서 도움이 됨

1. 성능 튜닝에 투입할 시간을 벌 수 있음
- 기능 추가가 빨리 끝나서 성능에 집중할 시간을 더 벌 수 있음

2. 성능을 더 세밀하게 분석할 수 있음
- 프로파일러가 지적해주는 코드의 범위가 더 좁아질 것이고, 그래서 튜닝하기 쉬워짐
- 코드가 깔끔하면 개선안들이 더 잘 떠오를 것